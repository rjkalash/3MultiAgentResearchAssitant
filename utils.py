"""
Utility functions for the Multi-Agent Research Assistant
"""

import json
import os
from datetime import datetime
from typing import Dict, Any


def save_research_result(result: Dict[str, Any], filename: str = None) -> str:
    """
    Save research results to a JSON file
    
    Args:
        result: The research result dictionary
        filename: Optional custom filename
    
    Returns:
        Path to saved file
    """
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"research_result_{timestamp}.json"
    
    # Create results directory if it doesn't exist
    os.makedirs("results", exist_ok=True)
    
    filepath = os.path.join("results", filename)
    
    # Prepare data for JSON serialization
    save_data = {
        "timestamp": datetime.now().isoformat(),
        "query": result.get("query", ""),
        "final_summary": result.get("final_summary", ""),
        "research_results": result.get("research_results", []),
        "critique_feedback": result.get("critique_feedback", []),
        "iterations": result.get("iteration", 0),
        "max_iterations": result.get("max_iterations", 0)
    }
    
    with open(filepath, "w", encoding="utf-8") as f:
        json.dump(save_data, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Results saved to: {filepath}")
    return filepath


def load_research_result(filepath: str) -> Dict[str, Any]:
    """
    Load research results from a JSON file
    
    Args:
        filepath: Path to the JSON file
    
    Returns:
        Research result dictionary
    """
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    return data


def export_to_markdown(result: Dict[str, Any], filename: str = None) -> str:
    """
    Export research results to a markdown file
    
    Args:
        result: The research result dictionary
        filename: Optional custom filename
    
    Returns:
        Path to saved file
    """
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"research_report_{timestamp}.md"
    
    # Create results directory if it doesn't exist
    os.makedirs("results", exist_ok=True)
    
    filepath = os.path.join("results", filename)
    
    # Generate markdown content
    markdown_content = f"""# Research Report

**Generated**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Query

{result.get('query', 'N/A')}

## Summary

{result.get('final_summary', 'N/A')}

---

## Research Findings

"""
    
    for i, research in enumerate(result.get('research_results', []), 1):
        markdown_content += f"\n### Research Iteration {i}\n\n{research}\n\n"
    
    markdown_content += "\n---\n\n## Critique Feedback\n\n"
    
    for i, critique in enumerate(result.get('critique_feedback', []), 1):
        markdown_content += f"\n### Critique Round {i}\n\n{critique}\n\n"
    
    markdown_content += f"""
---

## Statistics

- **Total Iterations**: {result.get('iteration', 0)}
- **Max Iterations**: {result.get('max_iterations', 0)}
- **Research Rounds**: {len(result.get('research_results', []))}
- **Critique Rounds**: {len(result.get('critique_feedback', []))}

---

*Generated by Multi-Agent Research Assistant*
"""
    
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(markdown_content)
    
    print(f"✅ Markdown report saved to: {filepath}")
    return filepath


def validate_api_keys() -> Dict[str, bool]:
    """
    Validate that required API keys are present
    
    Returns:
        Dictionary with validation status for each key
    """
    from dotenv import load_dotenv
    load_dotenv()
    
    groq_key = os.getenv("GROQ_API_KEY")
    tavily_key = os.getenv("TAVILY_API_KEY")
    
    validation = {
        "groq": bool(groq_key and groq_key != "your_groq_api_key_here"),
        "tavily": bool(tavily_key and tavily_key != "your_tavily_api_key_here")
    }
    
    return validation


def print_validation_status():
    """
    Print API key validation status
    """
    validation = validate_api_keys()
    
    print("\n" + "="*60)
    print("API Key Validation")
    print("="*60)
    
    print(f"Groq API Key:   {'✅ Valid' if validation['groq'] else '❌ Missing or Invalid'}")
    print(f"Tavily API Key: {'✅ Valid' if validation['tavily'] else '❌ Missing or Invalid'}")
    
    if not all(validation.values()):
        print("\n⚠️  Please configure your API keys in the .env file")
        print("See SETUP.md for instructions")
    else:
        print("\n✅ All API keys are configured!")
    
    print("="*60 + "\n")


def format_time(seconds: float) -> str:
    """
    Format seconds into human-readable time
    
    Args:
        seconds: Time in seconds
    
    Returns:
        Formatted time string
    """
    if seconds < 60:
        return f"{seconds:.2f} seconds"
    elif seconds < 3600:
        minutes = seconds / 60
        return f"{minutes:.2f} minutes"
    else:
        hours = seconds / 3600
        return f"{hours:.2f} hours"


def truncate_text(text: str, max_length: int = 100) -> str:
    """
    Truncate text to maximum length with ellipsis
    
    Args:
        text: Text to truncate
        max_length: Maximum length
    
    Returns:
        Truncated text
    """
    if len(text) <= max_length:
        return text
    return text[:max_length-3] + "..."


if __name__ == "__main__":
    # Run validation when script is executed directly
    print_validation_status()

"""
Utility functions for the Multi-Agent Research Assistant
"""

import json
import os
from datetime import datetime
from typing import Dict, Any


def save_research_result(result: Dict[str, Any], filename: str = None) -> str:
    """
    Save research results to a JSON file
    
    Args:
        result: The research result dictionary
        filename: Optional custom filename
    
    Returns:
        Path to saved file
    """
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"research_result_{timestamp}.json"
    
    # Create results directory if it doesn't exist
    os.makedirs("results", exist_ok=True)
    
    filepath = os.path.join("results", filename)
    
    # Prepare data for JSON serialization
    save_data = {
        "timestamp": datetime.now().isoformat(),
        "query": result.get("query", ""),
        "final_summary": result.get("final_summary", ""),
        "research_results": result.get("research_results", []),
        "critique_feedback": result.get("critique_feedback", []),
        "iterations": result.get("iteration", 0),
        "max_iterations": result.get("max_iterations", 0)
    }
    
    with open(filepath, "w", encoding="utf-8") as f:
        json.dump(save_data, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Results saved to: {filepath}")
    return filepath


def load_research_result(filepath: str) -> Dict[str, Any]:
    """
    Load research results from a JSON file
    
    Args:
        filepath: Path to the JSON file
    
    Returns:
        Research result dictionary
    """
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    return data


def export_to_markdown(result: Dict[str, Any], filename: str = None) -> str:
    """
    Export research results to a markdown file
    
    Args:
        result: The research result dictionary
        filename: Optional custom filename
    
    Returns:
        Path to saved file
    """
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"research_report_{timestamp}.md"
    
    # Create results directory if it doesn't exist
    os.makedirs("results", exist_ok=True)
    
    filepath = os.path.join("results", filename)
    
    # Generate markdown content
    markdown_content = f"""# Research Report

**Generated**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Query

{result.get('query', 'N/A')}

## Summary

{result.get('final_summary', 'N/A')}

---

## Research Findings

"""
    
    for i, research in enumerate(result.get('research_results', []), 1):
        markdown_content += f"\n### Research Iteration {i}\n\n{research}\n\n"
    
    markdown_content += "\n---\n\n## Critique Feedback\n\n"
    
    for i, critique in enumerate(result.get('critique_feedback', []), 1):
        markdown_content += f"\n### Critique Round {i}\n\n{critique}\n\n"
    
    markdown_content += f"""
---

## Statistics

- **Total Iterations**: {result.get('iteration', 0)}
- **Max Iterations**: {result.get('max_iterations', 0)}
- **Research Rounds**: {len(result.get('research_results', []))}
- **Critique Rounds**: {len(result.get('critique_feedback', []))}

---

*Generated by Multi-Agent Research Assistant*
"""
    
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(markdown_content)
    
    print(f"✅ Markdown report saved to: {filepath}")
    return filepath


def validate_api_keys() -> Dict[str, bool]:
    """
    Validate that required API keys are present
    
    Returns:
        Dictionary with validation status for each key
    """
    from dotenv import load_dotenv
    load_dotenv()
    
    groq_key = os.getenv("GROQ_API_KEY")
    tavily_key = os.getenv("TAVILY_API_KEY")
    
    validation = {
        "groq": bool(groq_key and groq_key != "your_groq_api_key_here"),
        "tavily": bool(tavily_key and tavily_key != "your_tavily_api_key_here")
    }
    
    return validation


def print_validation_status():
    """
    Print API key validation status
    """
    validation = validate_api_keys()
    
    print("\n" + "="*60)
    print("API Key Validation")
    print("="*60)
    
    print(f"Groq API Key:   {'✅ Valid' if validation['groq'] else '❌ Missing or Invalid'}")
    print(f"Tavily API Key: {'✅ Valid' if validation['tavily'] else '❌ Missing or Invalid'}")
    
    if not all(validation.values()):
        print("\n⚠️  Please configure your API keys in the .env file")
        print("See SETUP.md for instructions")
    else:
        print("\n✅ All API keys are configured!")
    
    print("="*60 + "\n")


def format_time(seconds: float) -> str:
    """
    Format seconds into human-readable time
    
    Args:
        seconds: Time in seconds
    
    Returns:
        Formatted time string
    """
    if seconds < 60:
        return f"{seconds:.2f} seconds"
    elif seconds < 3600:
        minutes = seconds / 60
        return f"{minutes:.2f} minutes"
    else:
        hours = seconds / 3600
        return f"{hours:.2f} hours"


def truncate_text(text: str, max_length: int = 100) -> str:
    """
    Truncate text to maximum length with ellipsis
    
    Args:
        text: Text to truncate
        max_length: Maximum length
    
    Returns:
        Truncated text
    """
    if len(text) <= max_length:
        return text
    return text[:max_length-3] + "..."


if __name__ == "__main__":
    # Run validation when script is executed directly
    print_validation_status()
